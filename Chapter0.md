# Chapter0 Operating System interface

操作系统通过界面为用户程序提供服务。设计一个好的界面非常困难。一方面，我们希望接口简单而狭窄，因为这样可以更轻松地正确实现实现。另一方面，我们可能很想为应用程序提供许多复杂的功能。解决这种压力的技巧是设计依赖于一些机制的界面，这些机制可以组合起来以提供更多的通用性。

![image-20191217093803627](/Users/dylan/Library/Application Support/typora-user-images/image-20191217093803627.png)

Shell是一个普通程序，可从用户读取命令并执行命令。 shell是一个用户程序，而不是内核的一部分，这一事实说明了系统调用接口的强大功能：shell没有什么特别之处。这也意味着外壳易于更换；所以，现代Unix系统有多种外壳可供选择，每种外壳都有其自己的用户界面和脚本功能。 xv6 shell是Unix Bourne shell本质的简单实现。
## 进程和内存
xv6进程由用户空间内存（指令，数据和堆栈）和内核专有的每个进程状态组成。 Xv6可以分时共享进程：它透明地在等待执行的一组进程之间切换可用的CPU。当某个进程未执行时，xv6保存其CPU寄存器，并在下次运行该进程时恢复它们。内核将进程标识符或pid与每个进程相关联。
进程可以使用fork系统调用来创建新进程。 Fork创建一个称为子进程的新进程，该进程与调用进程的父进程完全相同。fork返回父进程和子进程。在父级中，fork返回孩子的pid；在子级中，它返回零。

下面是一些系统调用

![image-20191217094426500](/Users/dylan/Library/Application Support/typora-user-images/image-20191217094426500.png)





尽管子级最初具有与父级相同的内存内容，但是父级和子级执行时使用的是不同的内存和不同的寄存器：更改一个变量不会影响另一个变量。例如，当wait的返回值在父进程中存储到pid中时，它不会更改子进程中的pid。子代中的pid的值仍为零。
exec系统调用使用从文件系统中存储的文件加载的新的内存映像替换调用进程的内存。该文件必须具有特定的格式，该格式指定文件的哪一部分包含指令，哪一部分是数据，从哪条指令开始等。xv6使用ELF格式，第2章将对此进行详细讨论。当exec成功执行时，它不会返回到调用程序。相反，从文件加载的指令在ELF标头中声明的入口点开始执行。 Exec接受两个参数：包含可执行文件的文件名和一个字符串参数数组。例如

```c
     char *argv[3];
     argv[0] = "echo";
     argv[1] = "hello";
     argv[2] = 0;
     exec("/bin/echo", argv);
     printf("exec error\n");
```

该片段将调用程序以程序`/bin/echo`的实例替换，并以参数列表echo hello运行。大多数程序会忽略第一个参数，这通常是程序的名称。
xv6 Shell使用上述调用代表用户运行程序。外壳的主要结构很简单；参见main（8701）。主循环使用getcmd从用户读取一行输入。然后，它调用fork，这将创建shell过程的副本。父级调用wait，而子级运行命令。

例如，如果用户在外壳上键入了“ echo hello”，则将以“ echo hello”作为参数调用runcmd。 runcmd（8606）运行实际命令。对于“ echo hello”，它将调用exec（8626）。如果exec成功，则子级将从echo执行指令，而不是runcmd。在某个时候，echo会调用exit，这将使父级从main（8701）中的等待状态返回。您可能想知道为什么fork和exec不能在单个调用中组合？稍后我们将看到，单独调用创建进程和加载程序是一个聪明的设计。
Xv6隐式分配大多数用户空间内存：fork分配父级内存的子级副本所需的内存，而exec分配足够的内存来保存可执行文件。一个在运行时需要更多内存的进程（可能是malloc）可以调用sbrk（n）将其数据内存增加n个字节。 sbrk返回新内存的位置。
Xv6没有提供用户概念或保护一个用户免受另一个用户侵害；用Unix术语，所有xv6进程都以root身份运行。

## I/O和文件描述符

文件描述符是一个小的整数，表示进程可以从中读取或写入的内核管理的对象。进程可以通过打开文件、目录或设备，可以通过创建管道，或通过复制现有的描述符来获得文件描述符。为简单起见，我们通常将文件描述符所指的对象称为“文件”；文件描述符接口抽象了文件，管道和设备之间的差异，使它们看起来都像字节流。
在内部，xv6内核使用文件描述符作为每个进程表的索引，因此每个进程都有一个从零开始的文件描述符专用空间。按照惯例，进程从文件描述符0（标准输入）读取，将输出写入文件描述符1（标准输出），并将错误消息写入文件描述符2（标准错误）。就像我们将看到的那样，shell利用约定来实现I / O重定向和管道。该外壳程序确保始终打开三个文件描述符（8707），默认情况下，它们是控制台的文件描述符。
读写系统调用从文件描述符读取字节并向其写入字节以打开由文件描述符命名的文件。

`read（fd，buf，n）`:读取文件,最多从文件描述符fd中读取n个字节，将它们复制到buf中，并返回读取的字节数。引用文件的每个文件描述符都有一个与之关联的偏移量。从当前文件开头+偏移量的位置读取数据，然后读取到偏移量+读取的字节数的位置,后续读取将返回第一次读取返回的字节之后的字节。当没有更多字节要读取时，读取将返回零以表示文件结束。
`write（fd，buf，n）`将buf中的n个字节写入文件描述符fd，并返回写入的字节数。仅在发生错误时才写入少于n个字节。与读操作类似，写操作以当前文件偏移量写入数据，然后将偏移量增加写入的字节数：每次写入都从上次中断的位置开始。
以下程序片段（cat的本质）将数据从其标准输入复制到其标准输出。如果发生错误，它将向标准错误写入一条消息。

```C
		 char buf[512];
     int n;
     for(;;){
       n = read(0, buf, sizeof buf);
       if(n == 0)
         break;
       if(n < 0){
         fprintf(2, "read error\n");
				 exit(); 
     	}
       if(write(1, buf, n) != n){
         fprintf(2, "write error\n");
         exit();
				} 
     }
```

在代码片段中要注意的重要一点是cat不知道它是从文件，控制台还是管道中读取数据。同样，cat不知道它是要打印到控制台，文件还是其他东西。使用文件描述符以及输入文件描述符0和输出文件描述符1的惯例让cat的实现简单了很多。
`close`系统调用将释放文件描述符，使其可以自由使用，以供将来的`open`，`pipe`或`dup`系统调用重用（请参见下文）。**新分配的文件描述符始终是当前进程中编号最小的未使用描述符**。
文件描述符和fork交互使I / O重定向易于实现。 **Fork会复制父文件的文件描述符表及其内存**，使得子进程与父进程有完全相同的打开文件开头。系统调用exec替换了调用进程的内存，但保留了其文件表。这使得Shell通过fork，重新打开选定的文件描述符，然后执行新程序来实现I / O重定向。这是shell程序为cat <input.txt命令运行的代码的简化版本：

```C
     char *argv[2];
     argv[0] = "cat";
     argv[1] = 0;
     if(fork() == 0) {							//子进程
       close(0);  									//关闭标准输入
       open("input.txt", O_RDONLY); //打开input.txt
       exec("cat", argv);
			}
```

子进程关闭文件描述符0(标准输入)后，需要确保open使用该文件描述符0作为新打开的input.txt:系统打开时自动选取可用的最小的文件描述符,也就是0。然后，Cat使用引用input.txt的文件描述符0（标准输入）执行。
xv6 shell中的I / O重定向代码完全以这种方式工作（8630）。回忆一下，在代码中，该shell程序已经fork出了子shell程序，并且runcmd将调用exec来加载新程序。现在应该清楚为什么将fork和exec分开调用是一个好主意。因为如果它们是分开的，则shell程序可以派生一个子shell，在子进程中使用open，close，dup来更改标准输入和输出文件描述符，然后执行。无需更改正在执行的程序（在我们的示例中为cat）。如果将fork和exec组合到单个系统调用中，则外壳将需要一些其他（可能更复杂）的方案来重定向标准输入和输出，否则程序本身将必须了解如何重定向I / O。
尽管fork复制了文件描述符表，但每个基础文件偏移量在父级和子级之间共享。考虑以下示例：

```C
		if(fork() == 0) {
       write(1, "hello ", 6);
       exit();
     } else {
       wait();
       write(1, "world\n", 6);
     }
```

在此片段的末尾，占用文件描述符1的文件将包含数据“hello world”。 父级中的写入（因为有wait，在子级完成后才进行）在子级停止写入的位置进行。 此行为有助于从Shell命令序列产生顺序输出，例如（echo hello; echo world）> output.txt。
`dup`系统调用复制了一个现有的文件描述符，并返回了一个新的文件描述符，该描述符引用了相同的基础I / O对象。 两个文件描述符共享一个偏移量，就像fork复制的文件描述符一样。 这是将hello world写入文件的另一种方法

```C
     fd = dup(1);
     write(1, "hello ", 6);
     write(fd, "world\n", 6);
```

如果两个文件描述符是通过fork和dup调用序列从同一原始文件描述符派生的，则它们共享一个偏移量。否则，文件描述符不共享偏移量，即使它们open同一文件。

 Dup允许shell程序执行以下命令：

`ls existing-file non-existing-file > tmp1 pipe 2>&1`

 2>＆1告诉外壳程序给命令一个文件描述符2，该文件描述符是复制于描述符的类别1.现有文件的名称和不存在文件的错误消息都将显示在文件tmp1中。 xv6 Shell不支持错误文件描述符的I / O重定向，但是现在你知道如何实现它了。
文件描述符是一种强大的抽象，因为它们隐藏了它们所连接的对象的详细信息：写入文件描述符1的进程可能正在写入文件或是控制台的设备或管道。
## 管道pipe
管道是一个小的内核缓冲区，以一对文件描述符的形式暴露给进程，一个用于读取，一个用于写入。将数据写入管道的一端可使该数据可从管道的另一端读取。管道为流程进行通信提供了一种方法。
以下示例代码使用标准输入连接到管道的读取端运行程序wc。

```c
 		 int p[2];
     char *argv[2];
     argv[0] = "wc";
     argv[1] = 0;
     pipe(p);//调用管道,并将读取和写入文件描述符记录在数组p中
     if(fork() == 0) {//创建一个新的管道
       close(0);//关闭读
       dup(p[0]);//将读取端复制到文件描述符0上
       close(p[0]);//关闭p中的文件描述符(读)
       close(p[1]);//关闭p中的文件描述符(写)
       exec("/bin/wc", argv);
     } else {
       close(p[0]);
       write(p[1], "hello world\n", 12);
       close(p[1]);
      }
```

程序调用管道，管道创建一个新管道，并将读取和写入文件描述符记录在数组p中。 在fork之后，父级和子级都具有引用管道的文件描述符。 子进程将读取端复制到文件描述符0上，关闭p中的文件描述符，然后执行wc。 当wc从其标准输入中读取时，它将从管道中读取。 父级关闭管道的读取侧，写入管道，然后关闭写入侧。
如果没有可用数据，在管道上读的进程会一致等待,直到有数据写入管道,或者所有写入管道的文件描述符都被关闭  在后一种情况下，读取将返回0，就像到达数据文件的末尾一样。,对于子进程来说， 读取直到新数据不可能到达为止一直阻塞,在执行上述wc之前，关闭管道的写端很重要：如果wc的文件描述符之一指向管道的写端 ，wc将永远看不到文件结尾。

> If no data is available, a read on a pipe waits for either data to be written or all file descriptors referring to the write end to be closed; in the latter case, read will re- turn 0, just as if the end of a data file had been reached. The fact that read blocks until it is impossible for new data to arrive is one reason that it’s important for the child to close the write end of the pipe before executing wc above: if one of wc’s file descriptors referred to the write end of the pipe, wc would never see end-of-file.

xv6 shell实现了管道，例如`grep fork sh.c | wc -l `  与上述代码（8650）类似。子进程创建管道来连接路径
管道的左端与右端。然后，它在管道的左端调用fork和runcmd，在右端调用fork和runcmd，并等待两者完成。管道的右端可能是一个本身就包括管道的命令（例如a | b | c），该管道本身派生了两个新的子进程（一个用于b，一个用于c）。因此，外壳可以创建进程树。该树的叶子是命令，内部节点是等待左右子节点完成的进程。
管道似乎没有临时文件强大：

管道:` echo hello world | wc`

可以在没有管道的情况下实现:  `     echo hello world >/tmp/xyz; wc </tmp/xyz`
在这种情况下，管道比临时文件至少具有四个优点:

1. 管道会自动清理自己；通过文件重定向，shell必须在完成后小心删除/ tmp / xyz。
2. 管道可以传递任意长的数据流，而文件重定向需要磁盘上有足够的可用空间来存储所有数据。
3. 管道允许并行执行管，而文件要求第一个程序在第二个启动之前完成。
4. 如果要实现进程间通信，则管道的阻塞读写比文件的非阻塞语义更有效。

## 文件系统

xv6文件系统提供了数据文件和目录，这些数据文件是未解释的字节数组，而目录包含对数据文件和其他目录的命名引用。 这些目录形成一棵树，从一个称为根的特殊目录开始。 类似于/ a / b / c的路径是指根目录/中名为a的目录中名为b的目录中名为c的文件或目录。 不以/开头的路径是相对于调用进程的当前目录进行评估的，可以使用chdir系统调用对其进行更改。 这两个代码片段都打开相同的文件（假设所有涉及的目录都存在）：

```C
     chdir("/a");
     chdir("b");
     open("c", O_RDONLY);


     open("/a/b/c", O_RDONLY);
```

第一个片段将进程的当前目录更改为/a/ b； 第二个既不引用也不更改进程的当前目录。
有多个系统调用来创建新文件或目录：

mkdir创建新目录

使用O_CREATE标志打开将创建新数据文件

而mknod将创建新设备文件。 

此示例说明了以上三个：

```C
mkdir("/dir");
fd = open("/dir/file", O_CREATE|O_WRONLY);
close(fd);
mknod("/console", 1, 1);
```

Mknod在文件系统中创建一个文件，但是该文件没有内容。 而是，文件的元数据将其标记为设备文件，并记录主要和次要设备号（mknod的两个参数），它们唯一地标识内核设备。 当一个过程稍后打开文件时，内核会将读写系统调用转移到内核设备实现中，而不是将它们传递到文件系统中。
fstat检索有关文件描述符引用的对象的信息。 它将填充一个stat stat，在stat.h中定义为：

```C
#define T_DIR  1 // Directory
#define T_FILE 2 // File
#define T_DEV  3 // Device

     struct stat {
       short type;  // Type of file
       int dev;     // File system’s disk device
       uint ino;    // Inode number
       short nlink; // Number of links to file
       uint size;   // Size of file in bytes
};
```

文件名与文件本身不同；同一基础文件（称为索引节点inode）可以具有多个名称（称为链接link）。链接系统调用将创建另一个文件系统名称，该名称引用与现有文件相同的索引节点。下面创建了一个名为a和b的新文件。

```
 	 open（"a"，O_CREATE | O_WRONLY）;
   link（"a"，"b"）;
```

从a读取/写入到a 与从b读取/写入到b 相同。每个索引节点由唯一的索引节点号标识。在上面的代码序列之后，可以通过检查fstat的结果确定a和b引用相同的基础内容：两者将返回相同的inode编号（ino），并且nlink计数将设置为2。
取消链接系统调用即为从文件系统中删除一个名称。仅当文件的链接计数为零且没有文件描述符引用该文件的索引节点和容纳其内容的磁盘空间时，才释放它们。因此`unlink("a")`将索引节点和文件内容保留为b。

```c
		 fd = open（"/tmp/xyz",O_CREATE | O_RDWR）;
     unlink（"/tmp/xyz"）;
```

👆这是一种创建临时inode的惯用方法，当进程关闭fd或退出时将对其进行清理。
用于文件系统操作的Shell命令是作为用户级程序（例如mkdir，ln，rm等）实现的。该设计允许任何人通过添加新的用户级程序来使用新的用户命令扩展Shell。
cd是一个例外，它内置在shell程序中（8716）。cd必须更改shell本身的当前工作目录。 如果cd是作为常规命令运行的，则外壳程序将派生一个子进程，该子进程将运行cd，而cd会更改该子进程的工作目录。 父级（即shell程序）的工作目录不会更改。

## Real world

Unix结合了“标准”文件描述符，管道和方便的shell语法对其进行操作，这是编写通用可重用程序的一项重大进步。这个想法激发了“软件工具”的整个文化，这种文化对Unix的强大功能和普及性负有责任。shell程序是第一种所谓的“脚本语言”。Unix系统调用接口在今天仍然存在于BSD，Linux和Mac OS X等系统。
Unix系统调用接口已通过可移植操作系统接口（POSIX）标准进行了标准化。 Xv6不兼容POSIX。它没有完全实现系统调用（包括诸如lseek之类的基本调用）。我们对xv6的主要目标是简化和清晰，同时提供一个类似于UNIX的简单系统调用接口。有些人用一些其他的基本系统调用和一个简单的C库扩展了xv6，以便可以运行基本的Unix程序。但是，与xv6相比，现代内核提供了更多的系统调用和更多种内核服务。例如，它们支持联网，窗口系统，用户级线程，许多设备的驱动程序等。现代内核不断快速发展，并提供了POSIX以外的许多功能。
在很大程度上，现代Unix派生的操作系统没有遵循早期的Unix模型，即将设备公开为特殊文件，例如上面讨论的控制台设备文件。 Unix的作者继续构建Plan 9，该计划将“资源就是文件”的概念应用到现代设施中，将网络，图形以及其他资源表示为文件或文件树。
文件系统抽象是一个强大的想法。即使这样，也存在用于操作系统接口的其他模型。 Multics是Unix的前身，它以一种类似于内存的方式抽象了文件存储，从而产生了截然不同的界面风格。 Multics设计的复杂性直接影响了Unix的设计师，后者试图构建更简单的东西。
本书探讨了xv6如何实现其类似Unix的接口，但是这些思想和概念不仅适用于Unix。任何操作系统都必须将进程多路复用到基础硬件上，将进程彼此隔离，并提供用于受控的进程间通信的机制。研究xv6之后，你应该能够查看其他更复杂的操作系统，并了解这些系统中xv6的基本概念。